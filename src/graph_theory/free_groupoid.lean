import graph_theory.path_category
import graph_theory.paths
import category_theory.quotient
import category_theory.groupoid
import group_theory.free_group

open path directed_multigraph category_theory free_group

universes v v₁ u u₁

variables {V : Type u}

namespace multigraph

def free (G : directed_multigraph.{v+1} V) : multigraph V :=
{ edge := λ s t, G.edge s t ⊕ G.edge t s,
  inv := λ s t, equiv.sum_comm _ _ }

variable {G : multigraph.{v} V}

def rev {s t : V} : G.edge s t → G.edge t s := (G.inv s t).to_fun

lemma rev_inl (G : directed_multigraph.{v+1} V) {s t : V} (e : G.edge s t) :
  @rev V (free G) s t (sum.inl e) = sum.inr e := rfl

lemma rev_inr (G : directed_multigraph.{v+1} V) {s t : V} (e : G.edge s t) :
  @rev V (free G) t s (sum.inr e) = sum.inl e := rfl

-- If we can reverse edges, then we can reverse paths
@[simp]
def path_rev : Π {a b : V}, G.path a b → G.path b a
| _ _ p[] := p[]
| _ _ (e :: l) := concat (path_rev l) p[rev e]

variable (G)

-- rev e should be the inverse of e in the free groupoid
inductive red.step : Π (a b : paths G.to_directed_multigraph), (a ⟶ b) → (a ⟶ b) → Prop
| rev {a b} (e : G.edge a b) : red.step a a p[e, rev e] p[]

@[derive category]
def free_groupoid := quotient (red.step G)

variable {G}

-- path_rev gives inverses as expected
lemma rev_concat_map_id {a b} (p : a ⟶ b) :
  (quotient.functor (red.step G)).map (p ≫ path_rev p) = 𝟙 _ :=
begin
  induction p with s h s t e l ih,
  refl,
  set F := quotient.functor (red.step G),
  have : F.map ((e::l) ≫ path_rev (e::l))
    = F.map p[e] ≫ F.map (l ≫ path_rev l) ≫ F.map p[rev e],
  { have : path_rev (e :: l) = concat (path_rev l) p[rev e] := rfl,
    rw this,
    rw cons_as_concat,
    repeat { rw concat_as_comp },
    repeat { rw F.map_comp },
    simp, },
  rw this,
  rw ih,
  apply category_theory.quotient.sound,
  exact red.step.rev e
end

instance : groupoid (free_groupoid G) :=
groupoid.of_trunc_split_mono $ λ x y f, quot.rec_on_subsingleton f $ λ p,
trunc.mk { retraction := (quotient.functor _).map (path_rev p),
           id' := by simpa using rev_concat_map_id p }

end multigraph

namespace free_groupoid

variables (G : directed_multigraph.{v+1} V)

@[derive category, derive groupoid]
def free_groupoid := multigraph.free_groupoid (multigraph.free G)

variable {G}

def of {s t : free_groupoid G} : G.edge s.as t.as → (s ⟶ t) :=
λ e, (quotient.functor _).map p[sum.inl e]

lemma free_groupoid.induction {C : Π {s t : free_groupoid G}, (s ⟶ t) → Prop}
  (h_id : ∀ {s}, C (𝟙 s))
  (h_of : ∀ (s t : free_groupoid G) (e : G.edge s.as t.as), C (of e))
  (h_inv : ∀ {s t : free_groupoid G} {f : s ⟶ t}, C f → C (inv f))
  (h_comp : ∀ {x y z : free_groupoid G} (f : x ⟶ y) (g : y ⟶ z), C f → C g → C (f ≫ g))
  {s t} (f : s ⟶ t)
  : C f :=
category_theory.quotient.induction _
begin
  intros _ _ p,
  induction p with a a b c e l ih,
  { exact h_id },
  { rw [cons_as_concat, concat_as_comp, functor.map_comp],
    apply h_comp,
    { cases e,
      { exact h_of { as := a } {as := b } e },
      { change C (inv $ @of _ _ {as := b} {as := a} e),
        exact h_inv (h_of _ _ _),
      },
    },
    { exact ih } }
end f

variables {D : Type u₁} [𝒟 : groupoid.{v₁} D]
  (F : graph_hom G (as_graph D))
include 𝒟 F

def to_groupoid : free_groupoid G ⥤ D :=
category_theory.quotient.lift _
  (functor_of_edge_map { obj := F.obj,
            edge := λ a b f, sum.rec_on f (λ e, F.edge e) (λ e, inv $ F.edge e)} ) $
  begin
    rintros _ _ _ _ ⟨x, y, e⟩,
    rw [cons_as_concat, concat_as_comp, functor.map_comp],
    repeat { rw [functor_of_edge_map.map_edge] },
    rw [nil_as_id, category_theory.functor.map_id],
    cases e,
    { rw multigraph.rev_inl, simp, },
    { rw multigraph.rev_inr, simp, },
  end

lemma to_groupoid.obj {s : free_groupoid G} :
  (to_groupoid F).obj s = F.obj s.as := rfl

lemma to_groupoid.map_of {s t : free_groupoid G} (e : G.edge s.as t.as) :
  (to_groupoid F).map (of e) = F.edge e ≫ 𝟙 _ := rfl

omit F

-- Morally, a groupoid is freely generated by a subgraph it the embedding satisfies the UMP,
-- i.e. graph homs lift uniquely to functors. But this definition would involve 2 universe
-- parameters? Instead we offer this simple charaterisation: a groupoid is freely generated by
-- a subgraph if the induced map from the free groupoid is fully faithful. From this condition
-- we should be able to derive the UMP.
class freely_generating (S : subgraph (as_graph D)) extends
  full (to_groupoid $ subgraph_embedding S),
  faithful (to_groupoid $ subgraph_embedding S)

end free_groupoid
