/-
Copyright (c) 2019 Amelia Livingston. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Amelia Livingston
-/

import group_theory.congruence
import algebra.associated

/-!
# Localizations of commutative monoids

The definition of a commutative ring localization does not rely on the ring's addition.
We characterize the localization of a commutative monoid `X` at a submonoid `Y` up to
isomorphism; that is, a commutative monoid `Z` is the localization of `X` at `Y` iff we can find a
monoid homomorphism `f : X →* Z` satisfying 3 properties:
1. For all `y : Y`, there exists `z : Z` such that `f y * z = 1`;
2. For all `z : Z`, there exists `(x, y) : X × Y` such that `z * f y = f x`;
3. For all `x, y : X`, `f x = f y` iff there exists `c : Y` such that `x * c = y * c`.

We also define the quotient of `X × Y` by the unique congruence relation `r` on
`X × Y` such that for any other congruence relation `r'` on `X × Y` where for all `y ∈ Y`,
`(1, 1) ∼ (y, y)` under `r'`, we have that `(x₁, y₁) ∼ (x₂, y₂)` by `r'` implies
`(x₁, y₁) ∼ (x₂, y₂)` by `r`. We show this relation is equivalent to the standard localization
relation.
This defines the localization as a quotient type, but the majority of subsequent lemmas in the file
are given in terms of localizations up to isomorphism, using maps which satisfy the characteristic
predicate.

Given such a map `f`, we can define the quotient map `monoid_localization.mk` sending
`(x, y) : X × Y` to `(f x) * (f y)⁻¹`, and `monoid_localization.lift`, the homomorphism from `Z`
induced by a homomorphism from `X` which maps elements of `Y` to invertible elements of the
codomain. Similarly, given commutative monoids `V, U`, a submonoid `W` of `V` and a map from
`V` to `U` satisfying the above predicate - so that `U` is the localization of `V` at `W` - then a
homomorphism `g : X →* V` such that `g(Y) ⊆ W` induces a homomorphism of localizations,
`monoid_localization.map`, from `Z` to `U`.

We specialize some of these functions to the case where the submonoid is generated by one element
in the section `away`.

We prove that the localization as a quotient type satisfies the characteristic predicate.

The last section of the file concerns commutative groups isomorphic to the localization of `X` at
itself. This localization, known as the Grothendieck group of a commutative monoid, defines a
functor from the category of commutative monoids to the category of commutative groups which is
left adjoint to the forgetful functor, and whose action on morphisms is defined by
`completion_map`.

Lastly, we show the positive rationals are the Grothendieck group of the positive naturals under
multiplication, and the integers are the Grothendieck group of the naturals under addition.

## Implementation notes

In maths it is natural to reason up to isomorphism, but in Lean we cannot naturally `rewrite` one
structure with an isomorphic one; one way around this is to isolate a predicate characterizing
a structure up to isomorphism, and reason about things that satisfy the predicate.

The infimum form of the localization congruence relation is chosen as 'canonical' here, since it
shortens some proofs.

We use `classical.epsilon` where possible; like `classical.some`, it reduces the number of
arguments to functions, but shortens proofs in comparison to `classical.some`.

We do not use the category theory library to define the adjunction (`hom_equiv` and
`hom_equiv_naturality_left_symm`) for the sake of clarity.

## Tags
localization, monoid localization, quotient monoid, congruence relation, characteristic predicate,
group completion, Grothendieck group, commutative monoid
-/
variables {X : Type*} [comm_monoid X] (Y : submonoid X) {Z : Type*}
          [comm_monoid Z] {V : Type*} [comm_monoid V] {W : submonoid V} (f : X →* Z)

namespace submonoid

/-- The characteristic predicate: if `f` satisfies `is_localization_map`, then `Z` is isomorphic
    to the localization of `X` at `Y`. -/
@[to_additive "The characteristic predicate: if `f` satisfies `is_localization_map`, then `Z` is isomorphic to the localization of `X` at `Y`."]
def is_localization_map :=
(∀ y : Y, ∃ z, f y * z = 1) ∧ (∀ z : Z, ∃ x : X × Y, z * f x.2 = f x.1) ∧
∀ x y, f x = f y ↔ ∃ c : Y, x * c = y * c

variables {f} (Z)

/-- Given a proof that there exists some homomorphism from `X` to `Z` satsifying
    `is_localization_map Y`, produces such a homomorphism. -/
@[to_additive "Given a proof that there exists some homomorphism from `X` to `Z` satsifying `is_localization_map Y`, produces such a homomorphism."]
noncomputable def localization_map :=
@classical.epsilon (X →* Z) ⟨monoid_hom.one⟩ (λ f, Y.is_localization_map f)

/-- A predicate characterizing `comm_monoid`s `Z` isomorphic to the localization of `X` at `Y`,
    requiring only a proof that there exists some homomorphism `f : X →* Z` satisfying
    `is_localization_map Y f`. -/
@[to_additive "A predicate characterizing `add_comm_monoid`s `Z` isomorphic to the localization of `X` at `Y`, requiring only a proof that there exists some homomorphism `f : X →+ Z` satisfying `is_localization_map Y f`."]
def is_localization := ∃ f : X →* Z, Y.is_localization_map f

namespace monoid_localization

/-- The congruence relation on `X × Y`, `X` a `comm_monoid` and `Y` a submonoid of `X`, whose
    quotient is the localization of `X` at `Y`, defined as the unique congruence relation on
    `X × Y` such that for any other congruence relation `s` on `X × Y` where for all `y ∈ Y`,
    `(1, 1) ∼ (y, y)` under `s`, we have that `(x₁, y₁) ∼ (x₂, y₂)` by `s` implies
    `(x₁, y₁) ∼ (x₂, y₂)` by `r`. -/
@[to_additive "The congruence relation on `X × Y`, `X` an `add_comm_monoid` and `Y` an `add_submonoid` of `X`, whose quotient is the localization of `X` at `Y`, defined as the unique congruence relation on `X × Y` such that for any other congruence relation `s` on `X × Y` where for all `y ∈ Y`, `(0, 0) ∼ (y, y)` under `s`, we have that `(x₁, y₁) ∼ (x₂, y₂)` by `s` implies `(x₁, y₁) ∼ (x₂, y₂)` by `r`."]
def r (Y : submonoid X) : con (X × Y) :=
lattice.Inf {c | ∀ y : Y, c 1 (y, y)}

/-- An alternate form of the congruence relation on `X × Y`, `X` a `comm_monoid` and `Y` a
    submonoid of `X`, whose quotient is the localization of `X` at `Y`. Its equivalence to `r` can
    be useful for proofs. -/
@[to_additive "An alternate form of the congruence relation on `X × Y`, `X` a `comm_monoid` and `Y` a submonoid of `X`, whose quotient is the localization of `X` at `Y`. Its equivalence to `r` can be useful for proofs."]
def r' : con (X × Y) :=
begin
  refine { r := λ a b : X × Y, ∃ c : Y, a.1 * b.2 * c = b.1 * a.2 * c,
    iseqv := ⟨λ a, ⟨1, rfl⟩, λ a b ⟨c, hc⟩, ⟨c, hc.symm⟩, _⟩,
    .. },
  { rintros a b c ⟨t₁, ht₁⟩ ⟨t₂, ht₂⟩,
    use b.2 * t₁ * t₂,
    simp only [submonoid.coe_mul],
    calc a.1 * c.2 * (b.2 * t₁ * t₂) = a.1 * b.2 * t₁ * c.2 * t₂ : by ac_refl
    ... = b.1 * c.2 * t₂ * a.2 * t₁ : by { rw ht₁, ac_refl }
    ... = c.1 * a.2 * (b.2 * t₁ * t₂) : by { rw ht₂, ac_refl } },
  { rintros a b c d ⟨t₁, ht₁⟩ ⟨t₂, ht₂⟩,
    use t₁ * t₂,
    calc (a.1 * c.1) * (b.2 * d.2) * (t₁ * t₂) = (a.1 * b.2 * t₁) * (c.1 * d.2 * t₂) :
      by ac_refl
    ... = (b.1 * d.1) * (a.2 * c.2) * (t₁ * t₂) : by { rw [ht₁, ht₂], ac_refl } }
end

/-- The congruence relation used to localize a `comm_monoid` at a submonoid can be expressed
    equivalently as an infimum (see `submonoid.r`) or explicitly (see `submonoid.r'`). -/
@[to_additive "The additive congruence relation used to localize an `add_comm_monoid` at a submonoid can be expressed equivalently as an infimum (see `add_submonoid.r`) or explicitly (see `add_submonoid.r'`)."]
theorem r_eq_r' : r Y = r' Y :=
le_antisymm (lattice.Inf_le $ λ _, ⟨1, by simp⟩) $
  lattice.le_Inf $ λ b H ⟨p, q⟩ y ⟨t, ht⟩,
    begin
      rw [← mul_one (p, q), ← mul_one y],
      refine b.trans (b.mul (b.refl _) (H (y.2 * t))) _,
      convert b.symm (b.mul (b.refl y) (H (q * t))); simp only [],
      rw [prod.mk_mul_mk, submonoid.coe_mul, ← mul_assoc, ht, mul_left_comm, mul_assoc],
      refl
    end

end monoid_localization

/-- The localization of a `comm_monoid` at one of its submonoids (as a quotient type). -/
@[to_additive "The localization of an `add_comm_monoid` at one of its submonoids (as a quotient type)."]
def monoid_localization := (monoid_localization.r Y).quotient

namespace monoid_localization

variables {Y}

@[to_additive]
lemma r_iff_exists {x y : X × Y} : r Y x y ↔ ∃ c : Y, x.1 * y.2 * c = y.1 * x.2 * c :=
by rw r_eq_r' Y; refl

variables (Y) {Z} (f)

/-- Given a localization map `f : X →* Z`, a section function sending `z : Z` to `(x, y) : X × Y`
    such that f x * (f y)⁻¹ = z. -/
@[to_additive "Given a localization map `f : X →+ Z`, a section function sending `z : Z` to `(x, y) : X × Y` such that f x - f y = z."]
noncomputable def sec :=
@classical.epsilon (Z → X × Y) ⟨λ z, 1⟩ (λ g, ∀ z, z * f (g z).2 = f (g z).1)

/-- Given a map `f : X →* Z` such that `f y` is invertible for all `y : Y`, produces a
    homomorphism sending `y : Y` to `(f y)⁻¹`. -/
@[to_additive "Given a map `f : X →+ Z` such that `f y` is invertible for all `y : Y`, produces a homomorphism sending `y : Y` to `-(f y)`."]
noncomputable def inv :=
@classical.epsilon (Y →* Z) ⟨monoid_hom.one⟩ (λ g, ∀ y : Y, f y * g y = 1)

variables {Y f}

@[simp, to_additive] lemma inv_mul (inv : Y → Z) (h : ∀ y : Y, f y * inv y = 1) (x y : Y) :
  inv (x * y) = inv x * inv y :=
begin
  rw [←one_mul (inv _), ←h, ←mul_one (f x), ←h, ←mul_assoc, ←f.map_mul,
      ←submonoid.coe_mul, mul_comm],
  assoc_rw mul_comm (inv _) (f _),
  rw [h, one_mul, mul_comm],
end

@[simp, to_additive] lemma inv_spec_right' (h : ∀ y : Y, ∃ z : Z, f y * z = 1) (y : Y) :
  f y * inv Y f y = 1 :=
@classical.epsilon_spec (Y →* Z) (λ g, ∀ y : Y, f y * g y = 1)
  ⟨⟨λ y, classical.some $ h y, by simpa using classical.some_spec (h 1),
   inv_mul (λ y, classical.some $ h y) $ λ y, classical.some_spec $ h y⟩,
   λ y, classical.some_spec $ h y⟩ y

@[simp, to_additive] lemma inv_spec_left' (h : ∀ y : Y, ∃ z : Z, f y * z = 1) (y : Y) :
  inv Y f y * f y = 1 :=
by rw [mul_comm, inv_spec_right' h]

@[simp, to_additive] lemma mul_inv_left (h : ∀ y : Y, ∃ z : Z, f y * z = 1) (y : Y) (w z) :
  w * inv Y f y = z ↔ w = f y * z :=
⟨λ H, by rw [←mul_one w, ←inv_spec_left' h y, ←H]; ac_refl,
 λ H, by rw [←one_mul z, ←inv_spec_left' h y, H]; ac_refl⟩

@[simp, to_additive] lemma mul_inv_right (h : ∀ y : Y, ∃ z : Z, f y * z = 1) (y : Y) (w z) :
  z = w * inv Y f y ↔ z * f y = w :=
by rw [eq_comm, mul_inv_left h, mul_comm, eq_comm]

@[simp, to_additive] lemma mul_inv (h : ∀ y : Y, ∃ z, f y * z = 1) {x₁ x₂} {y₁ y₂ : Y} :
  f x₁ * inv Y f y₁ = f x₂ * inv Y f y₂ ↔ f (x₁ * y₂) = f (x₂ * y₁) :=
by rw [mul_inv_left h, ←mul_assoc, mul_inv_right h, mul_comm x₂, f.map_mul, f.map_mul]

@[to_additive] lemma inv_inj (hf : ∀ y : Y, ∃ z, f y * z = 1) {y z}
  (h : inv Y f y = inv Y f z) : f y = f z :=
by rw [←mul_one (f y), ←inv_spec_right' hf z, ←h, ←mul_assoc, mul_comm (f y), mul_assoc,
       inv_spec_right' hf, mul_one]

@[to_additive] lemma inv_unique' (h : ∀ y : Y, ∃ z, f y * z = 1) {y : Y} {z} (H : f y * z = 1) :
  inv Y f y = z :=
by rw [←mul_one z, ←inv_spec_right' h y, ←mul_assoc, mul_comm z, H, one_mul]

variables (f)

/-- Given a localization map `f : X →* Z`, the surjection sending `(x, y) : X × Y` to
    `f x * (f y)⁻¹`. -/
@[to_additive "Given a localization map `f : X →+ Z`, the quotient map sending `(x, y) : X × Y` to `f x - f y`."]
noncomputable def mk (x : X) (y : Y) : Z := f x * inv Y f y

/-- Given a localization map `f : X →* Z`, the surjection sending `(x, y) : X × Y` to
    `f x * (f y)⁻¹` as a `monoid_hom`. -/
@[to_additive "Given a localization map `f : X →+ Z`, the quotient map sending `(x, y) : X × Y` to `f x - f y` as an `add_monoid_hom`."]
noncomputable def mk_hom : X × Y →* Z :=
(f.comp prod.monoid_hom.fst).mul $ (inv Y f).comp prod.monoid_hom.snd

variables {f}

@[simp, to_additive] lemma mk_mul (x₁ x₂ : X) (y₁ y₂ : Y) :
  mk f (x₁ * x₂) (y₁ * y₂) = mk f x₁ y₁ * mk f x₂ y₂ :=
(mk_hom f).map_mul (x₁, y₁) (x₂, y₂)

@[to_additive] lemma mk_one (x) : mk f x (1 : Y) = f x := by rw [mk, (inv Y f).map_one, mul_one]

@[to_additive] lemma localization_map_spec (h : is_localization Y Z) :
  Y.is_localization_map (Y.localization_map Z) :=
classical.epsilon_spec h

variables (hf : Y.is_localization_map f)
include hf

@[to_additive] lemma eq_iff_exists {x y} :
  f x = f y ↔ ∃ c : Y, x * c = y * c :=
hf.2.2 x y

@[simp, to_additive] lemma inv_spec_right (y : Y) :
  f y * inv Y f y = 1 :=
inv_spec_right' hf.1 y

@[simp, to_additive] lemma inv_spec_left (y : Y) :
  inv Y f y * f y = 1 :=
by rw [mul_comm, inv_spec_right hf]

@[to_additive] lemma inv_unique {y : Y} {z} (H : f y * z = 1) :
  inv Y f y = z :=
inv_unique' hf.1 H

@[simp, to_additive] lemma sec_spec (z : Z) :
  z * f (sec Y f z).2 = f (sec Y f z).1 :=
@classical.epsilon_spec (Z → X × Y) (λ g, ∀ z, z * f (g z).2 = f (g z).1)
  ⟨λ y, classical.some $ hf.2.1 y, λ y, classical.some_spec $ hf.2.1 y⟩ z

@[simp, to_additive] lemma sec_spec' (z : Z) :
  f (sec Y f z).1 = f (sec Y f z).2 * z :=
by rw [mul_comm, sec_spec hf]

@[simp, to_additive] lemma mk_sec (z : Z) :  mk f (sec Y f z).1 (sec Y f z).2 = z :=
show _ * _ = _, by rw [←sec_spec hf, mul_assoc, inv_spec_right hf, mul_one]

@[to_additive] lemma mk_surjective (z : Z) : ∃ x (y : Y), mk f x y = z :=
⟨(sec Y f z).1, (sec Y f z).2, mk_sec hf z⟩

@[simp, to_additive] lemma mk_spec (x) (y : Y) :
  mk f x y * f y = f x :=
show _ * _ * _ = _, by rw [mul_assoc, inv_spec_left hf, mul_one]

@[simp, to_additive] lemma mk_spec' (x) (y : Y) :
  f y * mk f x y = f x :=
by rw [mul_comm, mk_spec hf]

@[simp, to_additive] theorem eq_mk_iff_mul_eq {x} {y : Y} {z} :
  z = mk f x y ↔ z * f y = f x :=
⟨λ H, by rw [H, mk_spec hf], λ H, by rw [←mul_one z, ←inv_spec_right hf y, ←mul_assoc, H]; refl⟩

@[simp, to_additive] theorem mk_eq_iff_eq_mul {x} {y : Y} {z} :
  mk f x y = z ↔ f x = z * f y :=
by rw [eq_comm, eq_mk_iff_mul_eq hf, eq_comm]

@[to_additive] lemma mk_eq_iff_eq {x₁ x₂} {y₁ y₂ : Y} :
  mk f x₁ y₁ = mk f x₂ y₂ ↔ f (x₁ * y₂) = f (x₂ * y₁) :=
⟨λ H, by rw [f.map_mul, (mk_eq_iff_eq_mul hf).1 H, mul_assoc, mul_comm (f _), ←mul_assoc,
  mk_spec hf, f.map_mul],
 λ H, by rw [mk_eq_iff_eq_mul hf, mk, mul_assoc, mul_comm (inv Y f _), ←mul_assoc, ←f.map_mul,
  ←H, f.map_mul, mul_assoc, inv_spec_right hf, mul_one]⟩

@[to_additive] protected lemma eq {a₁ b₁} {a₂ b₂ : Y} :
  mk f a₁ a₂ = mk f b₁ b₂ ↔ ∃ c : Y, a₁ * b₂ * c = b₁ * a₂ * c :=
(mk_eq_iff_eq hf).trans $ hf.2.2 _ _

@[to_additive] protected lemma eq' {a₁ b₁} {a₂ b₂ : Y} :
  mk f a₁ a₂ = mk f b₁ b₂ ↔ r Y (a₁, a₂) (b₁, b₂) :=
by rw [monoid_localization.eq hf, r_iff_exists]

@[to_additive] lemma eq_iff_eq {g : X →* V} (hg : Y.is_localization_map g) {x y} :
  f x = f y ↔ g x = g y :=
(hf.2.2 _ _).trans (hg.2.2 _ _).symm

@[to_additive] lemma mk_eq_iff_mk_eq {g : X →* V} (hg : Y.is_localization_map g)
  {x₁ x₂} {y₁ y₂ : Y} :
  mk f x₁ y₁ = mk f x₂ y₂ ↔ mk g x₁ y₁ = mk g x₂ y₂ :=
(monoid_localization.eq' hf).trans (monoid_localization.eq' hg).symm

@[to_additive] lemma exists_of_sec_mk (x) (y : Y) :
  ∃ c : Y, x * (sec Y f $ mk f x y).2 * c = (sec Y f $ mk f x y).1 * y * c :=
(eq_iff_exists hf).1 $ (mk_eq_iff_eq hf).1 $ (mk_sec hf _).symm

@[to_additive] lemma exists_of_sec (x) :
  ∃ c : Y, x * (sec Y f $ f x).2 * c = (sec Y f $ f x).1 * c :=
(eq_iff_exists hf).1 $ by rw f.map_mul; exact sec_spec hf _

@[to_additive] lemma mk_eq_of_eq {a₁ b₁ : X} {a₂ b₂ : Y} (H : b₁ * a₂ = a₁ * b₂) :
  mk f a₁ a₂ = mk f b₁ b₂ :=
(mk_eq_iff_eq hf).2 $ H ▸ rfl

@[simp, to_additive] lemma mk_self (y : Y) :
  mk f (y : X) y = 1 := inv_spec_right hf y

@[simp, to_additive] lemma mk_self' (x) (H : x ∈ Y) :
  mk f x ⟨x, H⟩ = 1 :=
by convert mk_self hf _; refl

omit hf

@[simp, to_additive] lemma mul_mk_eq_mk_of_mul (x₁ x₂) (y : Y) :
  f x₁ * mk f x₂ y = mk f (x₁ * x₂) y :=
by rw [←mk_one, ←mk_mul, one_mul]

@[simp, to_additive] lemma mk_mul_eq_mk_of_mul (x₁ x₂) (y : Y) :
  mk f x₂ y * f x₁ = mk f (x₁ * x₂) y :=
by rw [mul_comm, mul_mk_eq_mk_of_mul]

@[simp, to_additive] lemma mul_mk_one_eq_mk (x) (y : Y) :
  f x * mk f 1 y = mk f x y :=
by rw [mul_mk_eq_mk_of_mul, mul_one]

include hf

@[simp, to_additive] lemma mk_mul_cancel_right (x : X) (y : Y) :
  mk f (x * y) y = f x :=
by rw [←mul_mk_one_eq_mk, f.map_mul, mul_assoc, mul_mk_one_eq_mk, mk_self hf, mul_one]

@[simp, to_additive] lemma mk_mul_cancel_left (x) (y : Y) :
  mk f ((y : X) * x) y = f x :=
by rw [mul_comm, mk_mul_cancel_right hf]

variables {g : X →* V} (hg : ∀ y : Y, ∃ v, g y * v = 1)
include hg

@[to_additive] lemma eq_of_eq {x y} (h : f x = f y) : g x = g y :=
let ⟨c, hc⟩ := (eq_iff_exists hf).1 h in
  by rw [←mul_one (g _), ←inv_spec_right' hg c, ←mul_assoc, ←g.map_mul, hc,
         g.map_mul, mul_assoc, inv_spec_right' hg, mul_one]

omit hg

@[to_additive] lemma comp_eq_of_eq {W : submonoid V} {U : Type*} [comm_monoid U]
  (hg : ∀ y : Y, g y ∈ W) {k : V →* U} (hk : W.is_localization_map k)
  {x y} (h : f x = f y) : k (g x) = k (g y) :=
let ⟨c, hc⟩ := (hf.2.2 _ _).1 h in (hk.2.2 _ _).2
  ⟨⟨g c, hg c⟩, show g _ * g _ = g _ * g _, by rw [←g.map_mul, hc, g.map_mul]⟩

include hg

/-- Given a localization map `f : X →* Z` and a map of `comm_monoid`s `g : X →* V` such that
    `g y` is invertible for all `y : Y`, the homomorphism induced from `Z` to `V` sending `z : Z`
    to `g x * (g y)⁻¹`, where `(x, y) : X × Y` are such that `z = f x *(f y)⁻¹`. -/
@[to_additive "Given a localization map `f : X →+ Z` and a map of `add_comm_monoid`s `g : X →+ V` such that `g y` is invertible for all `y : Y`, the homomorphism induced from `Z` to `V` sending `z : Z` to `g x - g y`, where `(x, y) : X × Y` are such that `z = f x - f y`."]
noncomputable def lift : Z →* V :=
⟨λ z, g (sec Y f z).1 * inv Y g (sec Y f z).2, by rw [mul_inv_left hg, mul_one];
   exact eq_of_eq hf hg (by rw [←sec_spec hf, one_mul]),
 λ x y, by rw [mul_inv_left hg, ←mul_assoc, ←mul_assoc, mul_inv_right hg,
   mul_comm _ (g (sec Y f y).1), ←mul_assoc, ←mul_assoc, mul_inv_right hg]; repeat {rw ←g.map_mul};
 exact eq_of_eq hf hg (by repeat {rw f.map_mul <|> rw sec_spec' hf}; ac_refl)⟩

variables {Y g}

@[simp, to_additive] lemma lift_mk (x y) :
  lift hf hg (mk f x y) = g x * inv Y g y :=
by erw mul_inv hg; exact eq_of_eq hf hg
  (by rw [f.map_mul, f.map_mul, sec_spec' hf, mul_assoc, mk_spec hf, mul_comm])

@[simp, to_additive] lemma lift_spec (z v) :
  lift hf hg z = v ↔ g (sec Y f z).1 = g (sec Y f z).2 * v :=
mul_inv_left hg _ _ v

@[simp, to_additive] lemma lift_spec_mul (z w v) :
  lift hf hg z * w = v ↔ g (sec Y f z).1 * w = g (sec Y f z).2 * v :=
begin
  rw mul_comm,
  show _ * (_ * _) = _ ↔ _,
  rw [←mul_assoc, mul_inv_left hg, mul_comm],
end

@[simp, to_additive] lemma lift_spec_mul' (z w v) :
  v = w * lift hf hg z ↔ g (sec Y f z).1 * w = g (sec Y f z).2 * v :=
by rw [eq_comm, mul_comm, lift_spec_mul]

@[simp, to_additive] lemma lift_mk_spec (x v) (y : Y) :
  lift hf hg (mk f x y) = v ↔ g x = g y * v :=
by rw [lift_mk hf hg, mul_inv_left hg]

@[simp, to_additive] lemma lift_mul_right (z) :
  lift hf hg z * g (sec Y f z).2 = g (sec Y f z).1 :=
show _ * _ * _ = _, by rw [mul_assoc, inv_spec_left' hg, mul_one]

@[simp, to_additive] lemma lift_mul_left (z) :
g (sec Y f z).2 * lift hf hg z = g (sec Y f z).1 :=
by rw [mul_comm, lift_mul_right]

@[simp, to_additive] lemma lift_of (x : X) :
  lift hf hg (f x) = g x :=
by rw [lift_spec, ←g.map_mul];
exact eq_of_eq hf hg (by rw [sec_spec' hf, f.map_mul])

@[to_additive] lemma lift_eq_iff {x y : X × Y} :
  lift hf hg (mk f x.1 x.2) = lift hf hg (mk f y.1 y.2) ↔ g (x.1 * y.2) = g (y.1 * x.2) :=
by rw [lift_mk, lift_mk, mul_inv hg]

@[simp, to_additive] lemma  lift_comp_of : (lift hf hg).comp f = g :=
by ext; exact lift_of hf hg _

omit hg

@[simp, to_additive] lemma lift_apply_of (j : Z →* V) :
  lift hf (submonoid.inv_comp_inv hf.1 j) = j :=
begin
  ext,
  rw lift_spec,
  show j _ = j _ * _,
  rw [←j.map_mul, sec_spec' hf],
end

@[to_additive] lemma funext {j k : Z →* V}
  (h : ∀ a, j.comp f a = k.comp f a) : j = k :=
begin
  rw [←lift_apply_of hf j, ←lift_apply_of hf k],
  congr' 1,
  ext,
  exact h x,
end

@[to_additive] lemma lift_unique {j : Z →* V}
  (hj : ∀ x, j (f x) = g x) : lift hf hg = j :=
begin
  ext,
  rw [lift_spec, ←hj, ←hj, ←j.map_mul],
  apply congr_arg,
  rw ←sec_spec' hf,
end

@[to_additive] lemma lift_id (x) : lift hf hf.1 x = x :=
monoid_hom.ext_iff.1 (lift_apply_of hf $ monoid_hom.id Z) x

@[to_additive] lemma lift_surjective_iff :
  function.surjective (lift hf hg) ↔ ∀ v : V, ∃ x : X × Y, v * g x.2 = g x.1 :=
⟨λ H v, let ⟨z, hz⟩ := H v in let ⟨x, hx⟩ := hf.2.1 z in
  ⟨x, by rw [←hz, (eq_mk_iff_mul_eq hf).2 hx, lift_mk, mul_assoc, mul_comm _ (g ↑x.2),
    inv_spec_right' hg, mul_one]⟩,
 λ H v, let ⟨x, hx⟩ := H v in ⟨mk f x.1 x.2, by rw [lift_mk, mul_inv_left hg, mul_comm, ←hx]⟩⟩

@[to_additive] lemma lift_injective_iff :
  function.injective (lift hf hg) ↔ ∀ x y, f x = f y ↔ g x = g y :=
⟨λ H x y, ⟨λ h, eq_of_eq hf hg h, λ h, by rw [←lift_of hf hg, ←lift_of hf hg] at h; exact H h⟩,
 λ H z w h, let ⟨x, hx⟩ := hf.2.1 z in let ⟨y, hy⟩ := hf.2.1 w in by
  rw [←mk_sec hf z, ←mk_sec hf w]; exact (mul_inv hf.1).2 ((H _ _).2 $ (mul_inv hg).1 h)⟩

variables (hy : ∀ y : Y, g y ∈ W) {U : Type*} [comm_monoid U] {k : V →* U}
          (hk : W.is_localization_map k)
omit hf

/-- Given a `comm_monoid` homomorphism `g : X →* V` where for submonoids `Y ⊆ X, W ⊆ V` we have
    `g(Y) ⊆ W`, the induced monoid homomorphism from the localization of `X` at `Y` to the
    localization of `V` at `W`: if `f : X →* Z` and `k : V →* U` are localization maps for `Y` and
    `W` respectively, we send `z : Z` to `k (g x) * (k (g y))⁻¹`, where `(x, y) : X × Y` are such
    that `z = f x * (f y)⁻¹`. -/
@[to_additive "Given an `add_comm_monoid` homomorphism `g : X →+ V` where for submonoids `Y ⊆ X, W ⊆ V` we have `g(Y) ⊆ W`, the induced `add_monoid` homomorphism from the localization of `X` at `Y` to the localization of `V` at `W`: if `f : X →+ Z` and `k : V →+ U` are localization maps for `Y` and `W` respectively, we send `z : Z` to `k (g x) - k (g y)`, where `(x, y) : X × Y` are such that `z = f x - f y`."]
noncomputable def map : Z →* U :=
@lift _ _ _ _ _ _ _ _ hf (k.comp g) $ submonoid.inv_comp hy hk.1

variables {k}

@[simp, to_additive] lemma map_of (x) :
  map hf hy hk (f x) = k (g x) := lift_of hf (submonoid.inv_comp hy hk.1) x

@[simp, to_additive] lemma map_comp_of :
  (map hf hy hk).comp f = k.comp g := lift_comp_of hf $ submonoid.inv_comp hy hk.1

@[to_additive] lemma map_mk (x) (y : Y) :
  map hf hy hk (mk f x y) = mk k (g x) ⟨g y, hy y⟩ :=
begin
  rw [map, lift_mk, mul_inv_left],
  { show k (g x) = k (g y) * _,
    rw mul_mk_eq_mk_of_mul,
    exact (mk_mul_cancel_left hk (g x) ⟨(g y), hy y⟩).symm },
  { exact submonoid.inv_comp hy hk.1 },
end

@[to_additive] lemma map_spec (z u) :
  map hf hy hk z = u ↔ k (g (sec Y f z).1) = k (g (sec Y f z).2) * u :=
lift_spec hf (submonoid.inv_comp hy hk.1) _ _

@[to_additive] lemma map_mul_right (z) :
  map hf hy hk z * (k (g (sec Y f z).2)) = k (g (sec Y f z).1) :=
lift_mul_right hf (submonoid.inv_comp hy hk.1) _

@[to_additive] lemma map_mul_left (z) :
  k (g (sec Y f z).2) * map hf hy hk z = k (g (sec Y f z).1) :=
by rw [mul_comm, map_mul_right hf]

@[simp, to_additive] lemma map_id (z : Z) :
  map hf (λ y, show monoid_hom.id X y ∈ Y, from y.2) hf z = z :=
lift_id hf z

@[to_additive] lemma map_comp_map {R T} [comm_monoid R] {S : submonoid R} [comm_monoid T]
  {j : R →* T} (hj : S.is_localization_map j) {l : V →* R} (hl : ∀ w : W, l w ∈ S) :
  (map hk hl hj).comp (map hf hy hk) = map hf (submonoid.comp_mem hy hl) hj :=
begin
  ext z,
  show j _ * _ = j (l _) * _,
  { rw [mul_inv_left, ←mul_assoc, mul_inv_right],
    show j _ * j (l (g _)) = j (l _) * _,
    rw [←j.map_mul, ←j.map_mul, ←l.map_mul, ←l.map_mul],
    exact comp_eq_of_eq hk hl hj
      (by rw [k.map_mul, k.map_mul, sec_spec' hk, mul_assoc, map_mul_right]),
    { exact submonoid.inv_comp (submonoid.comp_mem hy hl) hj.1 },
    { exact submonoid.inv_comp hl hj.1 }},
end

@[to_additive] lemma map_map (hk : W.is_localization_map k) {R T} [comm_monoid R]
  {S : submonoid R} [comm_monoid T] {j : R →* T} (hj : S.is_localization_map j)
  {l : V →* R} (hl : ∀ w : W, l w ∈ S) (x) :
  map hk hl hj (map hf hy hk x) = map hf (submonoid.comp_mem hy hl) hj x :=
by rw ←map_comp_map hf hy hk hj hl; refl

variables {g}

@[to_additive] lemma lift_inv {R} [comm_monoid R] {k : X →* R}
  (hk : Y.is_localization_map k) (z : Z) :
  lift hk hf.1 (lift hf hk.1 z) = z :=
begin
  rw lift_spec,
  cases hf.2.1 z with x hx,
  conv_rhs {congr, skip, rw (eq_mk_iff_mul_eq hf).2 hx},
  rw [mk, ←mul_assoc, mul_inv_right hf.1, ←f.map_mul, ←f.map_mul],
  apply eq_of_eq hk hf.1,
  rw [k.map_mul, k.map_mul, ←sec_spec hk, mul_assoc, lift_spec_mul],
  repeat {rw ←k.map_mul},
  apply eq_of_eq hf hk.1,
  repeat {rw f.map_mul}, rw [sec_spec' hf, ←hx],
  ac_refl,
end

/-- If `f : X →* Z` and `k : X →* R` are localization maps for a submonoid `Y`, we get an
    isomorphism of `Z` and `R`. -/
@[to_additive "If `f : X →+ Z` and `k : X →+ R` are localization maps for a submonoid `Y`, we get an isomorphism of `Z` and `R`."]
noncomputable def mul_equiv_of_localizations
  {R} [comm_monoid R] {k : X →* R} (hk : Y.is_localization_map k) : Z ≃* R :=
⟨lift hf hk.1, lift hk hf.1, lift_inv hf hk, lift_inv hk hf, monoid_hom.map_mul _⟩

include hf

@[to_additive] lemma is_localization_map_of_mul_equiv (k : Z ≃* V) :
  Y.is_localization_map (k.to_monoid_hom.comp f) :=
⟨submonoid.inv_comp_inv hf.1 k.to_monoid_hom, λ v, let ⟨z, hz⟩ := k.to_equiv.surjective v in
  let ⟨x, hx⟩ := hf.2.1 z in ⟨x, show v * k _ = k _, by rw [←hx, k.map_mul, ←hz]; refl⟩,
λ x y, (k.to_equiv.apply_eq_iff_eq _ _).trans $ hf.2.2 _ _⟩

@[to_additive] lemma is_localization_map_of_mul_equiv'
  {k : V ≃* X} (H : k.to_monoid_hom.map W = Y) :
  W.is_localization_map (f.comp k.to_monoid_hom) :=
let H' : k.to_monoid_hom.comap Y = W :=
  H ▸ (submonoid.ext' $ W.1.preimage_image_eq k.to_equiv.injective) in
⟨λ y, let ⟨z, hz⟩ := hf.1 ⟨k y, H ▸ set.mem_image_of_mem k y.2⟩ in ⟨z, hz⟩,
 λ z, let ⟨x, hx⟩ := hf.2.1 z in let ⟨v, hv⟩ := k.to_equiv.surjective x.1 in
 let ⟨w, hw⟩ := k.to_equiv.surjective x.2 in ⟨(v, ⟨w, H' ▸ show k w ∈ Y, from hw.symm ▸ x.2.2⟩),
 show z * f (k.to_equiv w) = f (k.to_equiv v), by rw [hv, hw, hx]⟩,
λ x y, show f _ = f _ ↔ _, by rw hf.2.2;
  exact ⟨λ ⟨c, hc⟩, let ⟨d, hd⟩ := k.to_equiv.surjective c in
⟨⟨d, H' ▸ show k d ∈ Y, from hd.symm ▸ c.2⟩, by erw [←hd, ←k.map_mul, ←k.map_mul] at hc;
  exact k.to_equiv.injective hc⟩, λ ⟨c, hc⟩, ⟨⟨k c, H ▸ set.mem_image_of_mem k c.2⟩,
  by erw ←k.map_mul; rw [hc, k.map_mul]; refl⟩⟩⟩

/-- Given localization maps `f : X →* Z, k : V →* U` for submonoids `Y, W` respectively, an
    isomorphism `j : X ≃* V` such that `j(Y) = W` induces an isomorphism of localizations
    `Z ≃* U`. -/
@[to_additive "Given localization maps `f : X →+ Z, k : V →+ U` for submonoids `Y, W` respectively, an isomorphism `j : X ≃+ V` such that `j(Y) = W` induces an isomorphism of localizations `Z ≃+ U`."]
noncomputable def mul_equiv_map
  (hk : W.is_localization_map k) (j : X ≃* V) (H : j.to_monoid_hom.map Y = W) :
  Z ≃* U :=
mul_equiv_of_localizations hf $ is_localization_map_of_mul_equiv' hk H

omit hf

-- Localization at a submonoid generated by one element

/-- Given `x : X`, if `φ : X →* Z` satisfies `is_away_map φ x`, `Z` is isomorphic to the
    localization of `X` at the submonoid generated by `x`. -/
def is_away_map (φ : X →* Z) (x : X) : Prop :=
is_localization_map (submonoid.powers x) φ

section away
  variables (φ : X →* Z) (x : X)

  /-- Given a localization map `φ : X →* Z` for the submonoid generated by `x : X`,
      `away.inv φ x n := (φ x)⁻ⁿ.` -/
  noncomputable def away.inv (n : ℕ) : Z := inv (submonoid.powers x) φ ⟨x ^ n, ⟨n, rfl⟩⟩

  /-- Given a localization map `φ : X →* Z` for the submonoid generated by `x : X`,
      `away.mk φ x y n := φ y * (φ x)⁻ⁿ.` -/
  noncomputable def away.mk (y : X) (n : ℕ) : Z := φ y * away.inv φ x n

  variables {φ x}

  @[simp] lemma away.mk_eq_mk {y : X} {n : ℕ} :
    @mk X _ (submonoid.powers x) _ _ φ y ⟨x ^ n, ⟨n, rfl⟩⟩ = away.mk φ x y n := rfl

  variables (hφ : is_away_map φ x) {ψ : X →* U}
  include hφ

  /-- Given a localization map `φ : X →* Z` for the submonoid generated by `x : X` and a
      `comm_monoid` homomorphism `ψ : X →* U` such that `ψ x` is invertible, the homomorphism
      induced from `Z` to `U` sending `z : Z` to `ψ y * (ψ x)⁻ⁿ`, where `(y, n) : X × ℕ` are
      such that `z = φ y * (φ x)⁻ⁿ`. -/
  noncomputable def away.lift {u} (hu : ψ x * u = 1) : Z →* U :=
  lift hφ $ λ ⟨y, n, hn⟩, ⟨u ^ n, show ψ y * u ^ n = 1, by
    rw [←hn, ψ.map_pow, ←mul_pow, hu, one_pow]⟩

  @[simp] lemma away.lift_of {u} (hu : ψ x * u = 1) (y) :
    away.lift hφ hu (φ y) = ψ y :=
  lift_of _ _ _

  @[simp] lemma away.lift_comp_of {u} (hu: ψ x * u = 1) :
    (away.lift hφ hu).comp φ = ψ :=
  lift_comp_of _ _

  /-- Given a localization map `φ : X →* Z` for the submonoid generated by `x : X` and a
      localization map `ρ : X →* U` for the submonoid generated by `x * y : X`, the induced map of
      localizations `Z →* U`. -/
  noncomputable def away_to_away_right {ρ : X →* U} {y : X}
    (hρ : is_away_map ρ (x * y)) : Z →* U :=
  away.lift hφ $ show ρ x * (away.mk ρ (x * y) y 1) = 1, by
    erw mul_mk_eq_mk_of_mul; convert mk_self hρ _; rw [subtype.coe_mk, pow_one]

end away

end monoid_localization
end submonoid
namespace add_submonoid
namespace monoid_localization

variables {A : Type*} {B : Type*} {C : Type*} [add_comm_monoid A]
  [add_comm_monoid B] [add_comm_monoid C]

/-- Given `x : A`, if `φ : A →+ B` satisfies `is_away_map φ x`, `B` is isomorphic to the
    localization of `A` at the submonoid generated by `x`. -/
def is_away_map (g : A →+ B) (x : A) : Prop := is_localization_map (add_submonoid.multiples x) g

attribute [to_additive add_submonoid.monoid_localization.is_away_map] submonoid.monoid_localization.is_away_map

section away
precedence `•`:70
localized "infix ` • ` := add_monoid.smul" in add_monoid
  variables (φ : A →+ B) (x : A)

  /-- Given a localization map `φ : A →+ B` for the submonoid generated by `x : A`,
      `away.neg φ x n := - n • (φ x).` -/
  noncomputable def away.neg (n : ℕ) : B := neg (add_submonoid.multiples x) φ ⟨n • x, ⟨n, rfl⟩⟩

  /-- Given a localization map `φ : A →+ B` for the submonoid generated by `x : A`,
      `away.mk φ x y n := φ y - n • (φ x).` -/
  noncomputable def away.mk (y : A) (n : ℕ) : B := φ y + away.neg φ x n

  variables {φ x}
  @[simp] lemma away.mk_eq_mk {y : A} {n : ℕ} :
    @mk A _ (add_submonoid.multiples x) _ _ φ y ⟨n • x, ⟨n, rfl⟩⟩ = away.mk φ x y n := rfl

  variables (hφ : is_away_map φ x) {ψ : A →+ C}
  include hφ

  /-- Given a localization map `φ : A →+ B` for the submonoid generated by `x : A` and an
      `add_comm_monoid` homomorphism `ψ : A →+ C` such that `ψ x` is invertible, the homomorphism
      induced from `B` to `C` sending `z : B` to `ψ y - n • (ψ x)`, where
      `(y, n) : A × ℕ` are such that `z = φ y - n • (φ x)`. -/
  noncomputable def away.lift {u} (hu : ψ x + u = 0): B →+ C :=
  lift hφ $ λ ⟨y, n, hn⟩, ⟨n • u, show ψ y + n • u = 0, by
    rw [←hn, ψ.map_smul, ←add_monoid.smul_add, hu, add_monoid.smul_zero]⟩

  @[simp] lemma away.lift_of {u} (hu : ψ x + u = 0) (y) :
    away.lift hφ hu (φ y) = ψ y :=
  lift_of _ _ _

  @[simp] lemma away.lift_comp_of {u} (hu: ψ x + u = 0) :
    (away.lift hφ hu).comp φ = ψ :=
  lift_comp_of _ _

  /-- Given a localization map `φ : X →+ Z` for the submonoid generated by `x : X` and a
      localization map `ρ : X →+ U` for the submonoid generated by `x + y : X`, the induced map of
      localizations `Z →+ U`. -/
  noncomputable def away_to_away_right {ρ : A →+ C} {y : A}
    (hρ : is_away_map ρ (x + y)) : B →+ C :=
  away.lift hφ $ show ρ x + (away.mk ρ (x + y) y 1) = 0, by
    erw add_mk_eq_mk_of_add; convert mk_self hρ _; rw [subtype.coe_mk, add_monoid.one_smul]

end away
end monoid_localization
end add_submonoid
namespace submonoid
namespace monoid_localization
open function

-- The localization as a quotient type

variables {Y f}

@[to_additive] lemma one_rel (y : Y) : r Y 1 (y, y) := λ b hb, hb y

/-- Given a `comm_monoid` `X` and submonoid `Y`, `mk'` sends `x : X, y ∈ Y` to the equivalence
    class of `(x, y)` in the localization of `X` at `Y`. -/
@[to_additive "Given an `add_comm_monoid` `X` and submonoid `Y`, `mk'` sends `x : X, y ∈ Y` to the equivalence class of `(x, y)` in the localization of `X` at `Y`."]
def mk' (x : X) (y : Y) : Y.monoid_localization := (r Y).mk' (x, y)

@[elab_as_eliminator, to_additive]
theorem ind {p : Y.monoid_localization → Prop}
  (H : ∀ (y : X × Y), p (mk' y.1 y.2)) (x) : p x :=
by rcases x; convert H x; exact prod.mk.eta.symm

@[elab_as_eliminator, to_additive]
theorem induction_on {p : Y.monoid_localization → Prop} (x)
  (H : ∀ (y : X × Y), p (mk' y.1 y.2)) : p x := ind H x

@[elab_as_eliminator, to_additive]
theorem induction_on₂ {p : Y.monoid_localization → Y.monoid_localization → Prop} (x y)
  (H : ∀ (x y : X × Y), p (mk' x.1 x.2) (mk' y.1 y.2)) : p x y :=
induction_on x $ λ x, induction_on y $ H x

@[elab_as_eliminator, to_additive]
theorem induction_on₃
  {p : Y.monoid_localization → Y.monoid_localization → Y.monoid_localization → Prop} (x y z)
  (H : ∀ (x y z : X × Y), p (mk' x.1 x.2) (mk' y.1 y.2) (mk' z.1 z.2)) : p x y z :=
induction_on₂ x y $ λ x y, induction_on z $ H x y

@[to_additive] instance : has_mul Y.monoid_localization := (r Y).has_mul

@[to_additive] instance : comm_monoid Y.monoid_localization :=
(r Y).comm_monoid

variables (Y)
/-- Natural homomorphism sending `x : X`, `X` a `comm_monoid`, to the equivalence class of
    `(x, 1)` in the localization of `X` at a submonoid. -/
@[to_additive "Natural homomorphism sending `x : X`, `X` an `add_comm_monoid`, to the equivalence class of `(x, 0)` in the localization of `X` at a submonoid."]
def of : X →* Y.monoid_localization :=
(r Y).mk'.comp ⟨λ x, (x, 1), refl 1, λ _ _, by simp only [prod.mk_mul_mk, one_mul]⟩

variables {Y}

@[to_additive] lemma is_localization_map_of : Y.is_localization_map (of Y) :=
⟨λ y, ⟨mk' 1 y, (r Y).eq.2 $ show r Y (_, 1 * y) 1, by simpa using (r Y).symm (one_rel y)⟩,
 λ z, induction_on z $ λ x, ⟨x, (r Y).eq.2 $ show r Y (x.1 * x.2, x.2 * 1) (x.1, 1), by
   rw [mul_comm x.2, ←mul_one (x.1, (1 : Y))];
   exact (r Y).mul ((r Y).refl (x.1, 1)) ((r Y).symm $ one_rel x.2)⟩,
λ x y, (r Y).eq.trans $ r_iff_exists.trans $
  show (∃ (c : Y), x * 1 * c = y * 1 * c) ↔ _, by rw [mul_one, mul_one]⟩

@[to_additive] lemma is_localization_of_quotient :
  Y.is_localization Y.monoid_localization := ⟨of Y, is_localization_map_of⟩

/-- Given a localization map `f : X →* Z` for a submonoid `Y`, we get an isomorphism between `Z`
    and the localization of `X` at `Y` as a quotient type. -/
@[to_additive "Given a localization map `f : X →+ Z` for a submonoid `Y`, we get an isomorphism between `Z` and the localization of `X` at `Y` as a quotient type."]
noncomputable def mul_equiv_of_quotient (hf : Y.is_localization_map f) :
  Y.monoid_localization ≃* Z :=
mul_equiv_of_localizations is_localization_map_of hf

/-- The localization of a `comm_monoid` `X` at the submonoid generated by an element `x : X`
    as a quotient type. -/
@[reducible] def away (x : X) := monoid_localization (submonoid.powers x)

/-- Given `x : X`, `X` a `comm_monoid`, the natural homomorphism sending `y : X` to the equivalence
    class of `(y, 1)` in the localization (as a quotient type) of `X` at the submonoid generated by
    `x`. -/
def away.of (x) : X →* away x := monoid_localization.of (submonoid.powers x)

lemma is_away_map_of (x : X) : is_away_map (away.of x) x :=
by convert is_localization_map_of

/-- Given a localization map `f : X →* Z` for the submonoid generated by some `x : X`, we get an
    isomorphism between `Z` and the localization (as a quotient type) of `X` at the submonoid
    generated by `x`. -/
noncomputable def mul_equiv_of_away (x : X) (hf : is_away_map f x) : away x ≃* Z :=
mul_equiv_of_quotient hf

end monoid_localization
end submonoid
namespace add_submonoid
namespace monoid_localization

variables {A : Type*} [add_comm_monoid A] (x : A) {B : Type*} [add_comm_monoid B]
/-- The localization of an `add_comm_monoid` `A` at the submonoid generated by an element `x : A`
    as a quotient type. -/
@[reducible] def away := monoid_localization (add_submonoid.multiples x)

attribute [to_additive add_submonoid.monoid_localization.away] submonoid.monoid_localization.away

/-- Given `x : A`, `A` an `add+comm_monoid`, the natural homomorphism sending `y : A` to the
    equivalence class of `(y, 0)` in the localization (as a quotient type) of `A` at the submonoid
    generated by `x`. -/
def away.of (x) : A →+ away x := monoid_localization.of (add_submonoid.multiples x)

lemma is_away_map_of (x : A) : is_away_map (away.of x) x :=
by convert is_localization_map_of

/-- Given a localization map `φ : A →+ B` for the submonoid generated by some `x : A`, we get an
    isomorphism between `B` and the localization (as a quotient type) of `A` at the submonoid
    generated by `x`. -/
noncomputable def add_equiv_of_away {φ : A →+ B} (x) (hφ : is_away_map φ x) : away x ≃+ B :=
add_equiv_of_quotient hφ

end monoid_localization
end add_submonoid
namespace submonoid
variables {Z}

--Grothendieck groups

/-- If `f : X →* Z` satisfies `is_completion_map`, `Z` is isomorphic to the localization of
    `X` at itself. -/
@[to_additive "If `f : X →+ Z` satisfies `is_completion_map`, `Z` is isomorphic to the localization of `X` at itself."]
def is_completion_map : (X →* Z) → Prop := is_localization_map (⊤ : submonoid X)

@[to_additive] lemma is_completion_mk {f : X →* Z} (h1 : ∀ x : X, ∃ z : Z, f x * z = 1)
  (h2 : ∀ z : Z, ∃ x : X × X, z * f x.2 = f x.1)
  (h3 : ∀ x y : X, f x = f y ↔ ∃ c : X, x * c = y * c) : is_completion_map f :=
⟨λ x, h1 x, λ z, let ⟨x, hx⟩ := h2 z in ⟨(x.1, ⟨x.2, trivial⟩), hx⟩,
  λ x y, ⟨λ h, let ⟨c, hc⟩ := (h3 _ _).1 h in ⟨⟨c, trivial⟩, hc⟩, λ ⟨c, hc⟩, (h3 _ _).2 ⟨c, hc⟩⟩⟩

variables (f)

namespace completion
open monoid_localization
/-- Given a completion map `f : X →* Z`, sends `(x, y) : X × X` to `f x * (f y)⁻¹`. -/
@[to_additive "Given a completion map `f : X →+ Z`, sends `(x, y) : X × X` to `f x - f y`."]
noncomputable def mk (x y : X) : Z :=
monoid_localization.mk f x (⟨y, trivial⟩ : (⊤ : submonoid X))

/-- Given a completion map `f : X →* Z`, sends `z : Z` to `(x, y) : X × X` such that
    `z = f x * (f y)⁻¹`. -/
@[to_additive "Given a completion map `f : X →+ Z`, sends `z : Z` to `(x, y) : X × X` such that `z = f x - f y`."]
noncomputable def sec (z : Z) : X × X :=
((sec (⊤ : submonoid X) f z).1, (sec (⊤ : submonoid X) f z).2)

/-- Given a completion map `f : X →* Z`, sends `z : Z` to `z⁻¹`. -/
@[to_additive "Given a completion map `f : X →+ Z`, sends `z : Z` to `-z`."]
noncomputable def inv (z : Z) :=
completion.mk f (completion.sec f z).2 (completion.sec f z).1

/-- Given a completion map `f : X →* Z` of `comm_monoid`s, `Z` is also a `comm_group`. -/
@[to_additive "Given a completion map `f : X →+ Z` of `add_comm_monoid`s, `Z` is also an `add_comm_group`."]
protected noncomputable def comm_group
  (hf : is_completion_map f) : comm_group Z :=
{ inv := completion.inv f,
  mul_left_inv := λ z, show mk f _ _ * z = 1, by
    conv_lhs {congr, skip, rw ←mk_sec hf z}; erw [←mk_mul, mul_comm];
    convert mk_self' hf _ _,
  .._inst_2 }

/-- Quotient map for the localization of `X` at itself as a quotient type. -/
@[to_additive "Quotient map for the localization of `X` at itself as a quotient type."]
def mk' (x y : X) :=
monoid_localization.mk' x (⟨y, trivial⟩ : (⊤ : submonoid X))

/-- Homomorphism sending `x : X` to `⟦(x, 1)⟧` in the localization of `X` at itself as a
    quotient type. -/
@[to_additive "Homomorphism sending `x : X` to `⟦(x, 0)⟧` in the localization of `X` at itself as a quotient type."]
def of := of (⊤ : submonoid X)

@[to_additive] noncomputable instance comm_group' :
  comm_group (monoid_localization (⊤ : submonoid X)) :=
completion.comm_group completion.of is_localization_map_of

@[to_additive] private lemma ex_inv {G : Type*} [comm_group G] (g : G) :
  ∃ h, g * h = 1 :=
⟨g⁻¹, mul_right_inv _⟩

@[to_additive] lemma id_is_completion_map {G : Type*} [comm_group G] :
  is_completion_map (monoid_hom.id G) :=
is_completion_mk ex_inv (λ x, ⟨(x, 1), mul_one x⟩) $
  λ x y, ⟨λ h, ⟨1, by simpa using h⟩, λ ⟨c, hc⟩, mul_right_cancel hc⟩

/-- Given a completion map from a `comm_group` `G` to a `comm_monoid` `Z`, we get an isomorphism
    of `G` and `Z`. -/
@[to_additive "Given a completion map from an `add_comm_group` `G` to an `add_comm_monoid` `Z`, we get an isomorphism of `G` and `Z`."]
noncomputable def mul_equiv_of_group (G : Type*) [comm_group G] {g : G →* Z}
  (hg : is_completion_map g) : G ≃* Z :=
mul_equiv_of_localizations id_is_completion_map hg

/-- Given `comm_monoid`s `X, Z`, `comm_group`s `G, H`, a completion map `g : X →* G` and any
    homomorphism `h : Z →* H`, a homomorphism `f : X →* Z` induces a homomorphism from `G` to `H`
    sending `z : G` to `h (f x) * (h (f y))⁻¹`, where `(x, y) : X × X` are such that
    `z = g x * (g y)⁻¹`. -/
@[to_additive "Given `add_comm_monoid`s `X, Z`, `add_comm_group`s `G, H`, a completion map `g : X →+ G` and any homomorphism `h : Z →+ H`, a homomorphism `f : X →+ Z` induces a homomorphism from `G` to `H` sending `z : G` to `h (f x) - h (f y)`, where `(x, y) : X × X` are such that `z = g x - g y`."]
noncomputable def map {G : Type*} {H : Type*} [comm_group G] [comm_group H]
  {g : X →* G} (hg : is_completion_map g) (h : Z →* H) (f : X →* Z) :
  G →* H := lift hg $ λ z, ⟨(h.comp f z)⁻¹, mul_right_inv _⟩

@[to_additive] lemma map_id {G : Type*} [comm_group G] {g : X →* G}
  (hg : is_completion_map g) (x) : completion.map hg g (monoid_hom.id X) x = x :=
by erw mul_inv_left (λ y, by convert hg.1 y); exact sec_spec' hg _

@[to_additive] lemma map_comp {G : Type*} {H : Type*} {J : Type*}
  [comm_group G] [comm_group H] [comm_group J] {f : X →* G} (hf : is_completion_map f)
  {g : Z →* H} (hg : is_completion_map g) {h : V →* J} (hh : is_completion_map h)
  (j : X →* Z) (k : Z →* V) :
  completion.map hf h (k.comp j) = (completion.map hg h k).comp (completion.map hf g j) :=
begin
  ext,
  erw [lift_spec, lift_spec_mul' hg],
  { show h (k _) * h (k (j _)) = h (k _) * h (k (j _)),
    rw [←h.map_mul, ←h.map_mul, ←k.map_mul, ←k.map_mul],
    apply comp_eq_of_eq hg _ hh,
    rw [g.map_mul, ←sec_spec hg, g.map_mul, mul_assoc, completion.map, lift_spec_mul,
        mul_comm, mul_comm _ (g (j (monoid_localization.sec ⊤ f x).2)), mul_assoc],
    refl,
    { tauto }},
    { exact (λ y, ex_inv _) }
end

variables {X} {G : Type*} [comm_group G] {g : X →* G}
  (hg : is_completion_map g) (H : Type*) [comm_group H]

/-- `Hom(F(X), H) ≃* Hom(X, K(H))`, where `X` is a `comm_monoid`, `H` is a `comm_group`, `K` is the
    forgetful functor and `F` is the functor sending `comm_monoid`s to their Grothendieck group,
    and whose action on morphisms is defined by `completion.map`. Given `f ∈ Hom(X, H)` and
    `g : X →* G` a completion map, we get a homomorphism sending `z : G` to `f x * (f y)⁻¹ : H`,
    where `(x, y) : X × X` are such that `z = g x * (g y)⁻¹.  -/
@[to_additive "`Hom(F(X), H) ≃+ Hom(X, K(H))`, where `X` is an `add_comm_monoid`, `H` is an `add_comm_group`, `K` is the forgetful functor and `F` is the functor sending `add_comm_monoid`s to their Grothendieck group, and whose action on morphisms is defined by `completion.map`. Given `f ∈ Hom(X, H)` and `g : X →+ G` a completion map, we get a homomorphism sending `z : G` to `f x - f y`, where `(x, y) : X × X` are such that `z = g x - g y`."]
noncomputable def hom_equiv : (X →* H) ≃* (G →* H) :=
{ to_fun := λ f, lift hg $ λ y, ⟨(f y)⁻¹, mul_right_inv _⟩,
  inv_fun := λ f, f.comp g,
  left_inv := λ f, monoid_hom.ext $ λ x, lift_of hg (λ _, ⟨_, mul_right_inv _⟩) _,
  right_inv := λ f, monoid_hom.ext $ λ x,
    (mul_inv_left (λ (y : (⊤ : submonoid X)), ex_inv (f.comp g y)) _ _ _).2 $
      show f _ = f _ * _, by rw [←sec_spec hg, ←f.map_mul, mul_comm],
  map_mul' := λ j k, monoid_hom.ext $ λ x, show _ * _ = (_ * _) * (_ * _),
    begin
      rw [mul_inv_left, ←mul_assoc, ←mul_assoc, mul_inv_right, mul_assoc, mul_assoc,
          mul_comm _ (k (monoid_localization.sec ⊤ g x).1), ←mul_assoc, ←mul_assoc,
          mul_inv_right, mul_assoc],
      { show _ * (k * j) _ = _,
        rw [mul_comm k j, mul_comm, mul_assoc], refl },
      all_goals {exact (λ y, ex_inv _)},
    end }

variables {X G H}

@[to_additive] lemma hom_equiv_naturality_left_symm {J : Type*} [comm_group J]
  {j : Z →* J} (hj : is_completion_map j) {f : X →* Z} {k : Z →* H} :
 (completion.hom_equiv hg H) (k.comp f) =
   ((completion.hom_equiv hj H) k).comp (completion.map hg j f) :=
begin
  ext a,
  erw [lift_spec, lift_spec_mul' hj, ←k.map_mul, ←k.map_mul],
  apply eq_of_eq hj,
  { exact (λ y, ex_inv _) },
  { rw [j.map_mul, j.map_mul, ←sec_spec hj, mul_assoc],
    erw lift_spec_mul,
    rw [mul_comm, mul_comm _ (j (f (monoid_localization.sec ⊤ g a).2)), mul_assoc],
    refl },
  { exact (λ y, ex_inv _) },
end

end completion
end submonoid

instance comm_group_of_pos_rat : comm_group {q : ℚ // 0 < q} :=
{ mul := λ x y, ⟨x.1 * y.1, mul_pos' x.2 y.2⟩,
  mul_assoc := λ x y z, subtype.ext.2 $ mul_assoc _ _ _,
  one := ⟨1, zero_lt_one⟩,
  one_mul := λ x, subtype.ext.2 $ one_mul _,
  mul_one := λ x, subtype.ext.2 $ mul_one _,
  inv := λ x, ⟨x.1⁻¹, inv_pos x.2⟩,
  mul_left_inv := λ x, subtype.ext.2 $ inv_mul_cancel $ ne_of_gt x.2,
  mul_comm := λ x y, subtype.ext.2 $ mul_comm _ _ }

/-- Natural inclusion homomorphism from the positive naturals to the positive rationals. -/
def pnat_to_pos_rat : ℕ+ →* {q : ℚ // 0 < q} :=
⟨λ n, ⟨(n : ℚ), nat.cast_pos.2 $ pnat.pos n⟩, rfl, λ x y, subtype.ext.2 $ nat.cast_mul x y⟩

theorem is_completion_pnat_to_pos_rat :
  submonoid.is_completion_map pnat_to_pos_rat :=
⟨λ y, ⟨⟨(y : ℚ)⁻¹, inv_pos'.2 $ nat.cast_pos.2 $ pnat.pos y⟩, mul_right_inv _⟩,
λ n, ⟨(⟨int.to_nat n.1.num, int.lt_to_nat.2 $ rat.num_pos_iff_pos.2 n.2⟩,
    ⟨⟨n.1.denom, n.1.pos⟩, trivial⟩),
  subtype.ext.2 $ show n.1 * n.1.denom = int.to_nat n.1.num,
    by rw rat.mul_own_denom_eq_num; norm_cast;
      rw int.to_nat_of_nonneg (le_of_lt (rat.num_pos_iff_pos.2 n.2))⟩,
λ x y, ⟨λ h, ⟨⟨1, trivial⟩, by rw [subtype.coe_mk, mul_one, subtype.ext,
  nat.cast_inj.1 (show (x.1 : ℚ) = _, from subtype.ext.1 h), mul_one]; refl⟩,
    λ ⟨⟨c, _⟩, hc⟩, mul_right_cancel hc ▸ rfl⟩⟩

/-- Natural inclusion homomorphism from the naturals to the integers. -/
def nat_to_int : ℕ →+ ℤ :=
⟨λ n, n, rfl, λ x y, rfl⟩

theorem is_completion_nat_to_int :
  add_submonoid.is_completion_map nat_to_int :=
⟨λ y, ⟨-(nat_to_int y), add_right_neg _⟩,
λ n, int.cases_on n (λ z, ⟨(z, ⟨0, trivial⟩), show int.of_nat z + 0 = z, by rw add_zero; refl⟩)
(λ z, ⟨(0, ⟨z + 1, trivial⟩), show -((z + 1) : ℤ) + ((z + 1) : ℤ) = 0, from add_left_neg _⟩),
  λ x y, ⟨λ h, ⟨⟨0, trivial⟩, (add_right_inj _).2 $ int.of_nat_inj h⟩,
    λ ⟨c, hc⟩, add_right_cancel hc ▸ rfl⟩⟩
